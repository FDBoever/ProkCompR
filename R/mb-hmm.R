#pfamscan2df
#=========================================================≠#
#' reads in pfamScan data
#'
#' @param inPath
#' @param clean_genome_names
#'
#' @return
#' @export
#'
#' @examples
#' df.pfam.all <- pfamscan2df(inPath = "/Users/sa01fd/DATA/MarbGenomics/PfamScan/", clean_genome_names=TRUE)

pfamscan2df <- function(inPath=NULL, clean_genome_names=TRUE){
  Files <- dir(inPath, pattern = '.faa.txt', full.names = T)
  output = c()
  genomeList = c()
  for(x in Files){
    pfam.in <- read.delim(x,header=FALSE,sep='',skip=28,na.strings ="", stringsAsFactors= F)
    colnames(pfam.in) <- c("seq_id",
                           "alignment_start",
                           "alignment_end",
                           "envelope_start",
                           "envelope_end",
                           "hmm_acc",
                           "hmm_name",
                           "type",
                           "hmm_start",
                           "hmm_end",
                           "hmm_length",
                           "bit_score",
                           "E_value",
                           "significance",
                           "clan")
    if(clean_genome_names==TRUE){
      genome = gsub('-','_',gsub('\\.','_', gsub('.faa.txt','',basename(x))))
    }else{
      genome = gsub('.faa.txt','',basename(x))
    }
    message(paste0('loading: ',genome))
    output = rbind(output,cbind(pfam.in, genome))
  }

  #format to have clean data.frame
  output = data.frame(output)
  return(output)
}



#pfam2pan
#=========================================================≠#
#' Convert pfam df to pan/abundance table
#' pfamscan2df
#' @param df data frame generated by pfamscan2df
#'
#' @return pan-abundance table
#' @export
#'
#' @examples
#' df.pfam.all <- pfamscan2df(inPath = "/Users/sa01fd/DATA/MarbGenomics/PfamScan/", clean_genome_names=TRUE)
#' pfam.pan <- pfam2pan(df.pfam.all)
pfam2pan <- function(df){
  pfam.pan <- df %>%
    dplyr::select(genome, hmm_name) %>%
    dplyr::group_by(genome) %>%
    dplyr::count(hmm_name) %>%
    spread(hmm_name,n, fill=0) %>%
    data.frame()

  rownames(pfam.pan)= pfam.pan[,1]
  pfam.pan = pfam.pan[,c(2:ncol(pfam.pan))]

  return(pfam.pan)
}




#---------------------------------------------------------------------------------------#
# INITIALISING PFAM DATA

#functions
#   pfamscan2df
#   pfam2pan

df.pfam.all <- pfamscan2df(inPath = "/Users/sa01fd/DATA/MarbGenomics/PfamScan/", clean_genome_names=TRUE)
pfam.pan <- pfam2pan(df.pfam.all)


# Download Pfam-A.clans.tsv from pfam ftp server (/current_release/Pfam-A.clans.tsv)
pfam.ann.inpath <- '/Users/sa01fd/DATA/MarbGenomics/AnnotateMachine/Pfam-A.clans.tsv'
pfam.annotations <- read.delim(file=pfam.ann.inpath,
                               header=FALSE,
                               col.names = c('pfam_acc', 'pfam_clan', 'pfam_short', 'pfam_short2', 'pfam_description'))


df.pfam.all <- df.pfam.all %>% dplyr::mutate(pfam_acc = sub("\\..*", "", hmm_acc))%>%
  dplyr::left_join(pfam.annotations, by='pfam_acc')


#summarise per locus_tag to add to anntation.tbl
df.pfam_per_locus <- df.pfam.all %>%
  dplyr::select(seq_id,hmm_acc, hmm_name, type,alignment_start,alignment_end, hmm_start,hmm_end,clan,genome,pfam_acc,pfam_clan,pfam_short,pfam_short2,pfam_description) %>%
  dplyr::group_by(seq_id,genome) %>%
  dplyr::summarise(hmm_acc=paste(hmm_acc,collapse=";"),
                   hmm_name=paste(hmm_name,collapse=";"),
                   type=paste(type,collapse=";"),
                   alignment_start=paste(alignment_start,collapse=";"),
                   alignment_end=paste(alignment_end,collapse=";"),
                   hmm_start=paste(hmm_start,collapse=";"),
                   hmm_end=paste(hmm_end,collapse=";"),
                   clan=paste(hmm_end,collapse=";"),
                   genome=paste(hmm_end,collapse=";"),
                   pfam_acc=paste(hmm_end,collapse=";"),
                   pfam_clan=paste(hmm_end,collapse=";"),
                   pfam_short=paste(hmm_end,collapse=";"),
                   pfam_short2=paste(hmm_end,collapse=";"),
                   pfam_description=paste(hmm_end,collapse=";")
                   )





#----------------------------------------------------------------------------------------
#
#   Utility functions for dealing with dbCAN output, = hmmScan
#
#----------------------------------------------------------------------------------------

#MAPPING FILES
#TCDB mapper

T2S  = read.delim('~/DATA/MarbGenomics/AnnotateMachine/TCDB_substrates.txt',header=FALSE,sep='\t')  #mapping substrates and chEBI iIDs
T2F  = read.delim('~/DATA/MarbGenomics/AnnotateMachine/TCDB_families.txt',header=FALSE,sep='\t') #mapping of families

colnames(T2S) = c('substrate_id','CHEBI_id')
T2S  = T2S %>% as_tibble()

colnames(T2F) = c('family_id','family')
T2F = T2F %>% as_tibble()

# hmm_hits  = read.delim('~/DATA/MarbGenomics/dbCAN_TCDB/Marinobacter_sp_FDB33_dbCAN_unique_for_cds_extraction.txt',header=FALSE,sep='\t')
# hmm_out  = read.delim('~/DATA/MarbGenomics/dbCAN_TCDB/Marinobacter_sp_FDB33.out',header=FALSE,sep=' ',skip=3)
# head(hmm_hits)
#--------------------------------------------------------------------------------------------#
# The below function may turn obsolete in the future,
#   it is based on an input file _unique_for_cds_extraction.txt as generated by DG's private pipeline
#   It is used to select the best hit per gene, not allowing multiple PFAM's per gene...
#   It remains active, for the sake of it, but I'd recommend to use another way
#--------------------------------------------------------------------------------------------#
# dbCan2df
#   function that goes and sort KOfam output data frame
#   this function will go and read files from dbCAN analysis based on D. Greens pipeline
#-------------------------------------------------------------------------------------------#

dbCan2df <- function(inPath=NULL, clean_genome_names=TRUE){
  hmmFiles <- dir(inPath, pattern = '_unique_for_cds_extraction.txt', full.names = T)
  output = c()
  genomeList = c()
  for(x in hmmFiles){
    inputHMM = read.delim(x, header=FALSE)
    if(clean_genome_names==TRUE){
      genome = gsub('-','_',gsub('\\.','_', gsub('_dbCAN_unique_for_cds_extraction.txt','',basename(x))))
    }else{
      genome = gsub('_dbCAN_unique_for_cds_extraction.txt','',basename(x))
    }
    print(paste0('loading: ',genome))
    output = rbind(output,cbind(inputHMM, genome))
  }
  colnames(output) = c('locus_tag','feature.id','genome')

  #format to have clean data.frame
  output = data.frame(output)
  return(output)
}

#usage
#kfm.df = dbCan2df(inPath='~/DATA/MarbGenomics/dbCAN_KOfam/', clean_genome_names=TRUE)
#tcdb.df = dbCan2df(inPath='~/DATA/MarbGenomics/dbCAN_TCDB/', clean_genome_names=TRUE)
#cazy.df = dbCan2df(inPath='~/DATA/MarbGenomics/dbCAN/', clean_genome_names=TRUE)


#-------------------------------------------------------------------#
# df2pan
#   function to convert a hmm.df to a pan/abundance table
#
#-------------------------------------------------------------------#

#' Title
#'
#' @param df
#'
#' @return
#' @export
#'
#' @examples
#' #kfm.pan = df2pan(kfm.df)
#' tcdb.pan = df2pan(tcdb.df)
#' cazy.pan = df2pan(cazy.df)
df2pan <- function(df){
  hmmpan <- df %>%
    group_by(genome) %>%
    count(feature.id) %>%
    spread(feature.id,n, fill=0) %>%
    data.frame()

  rownames(hmmpan)= hmmpan[,1]
  hmmpan = hmmpan[,c(2:ncol(hmmpan))]

  return(hmmpan)
}

#usage
#kfm.pan = df2pan(kfm.df)
#tcdb.pan = df2pan(tcdb.df)
#cazy.pan = df2pan(cazy.df)


#---------------------------------------------------------------------#
#	TCDB SPECIFIC CODE
#---------------------------------------------------------------------#
head(hmm_hits)

colnames(hmm_hits) = c('locus_tag','hmmid')

hmm_hits$family_id =
  sub(sprintf("^((?:[^.]*.){%d}).*", 3), "\\1", hmm_hits$hmmid) %>%
  substr(.,1,(nchar(.)-1))

hmm_hits$TDv =
  sub(sprintf("^((?:[^.]*.){%d})*", 2), "\\1", hmm_hits$hmmid)

hmm_hits = hmm_hits %>% as_tibble()

hmm_hits = hmm_hits %>% left_join(T2F, by="family_id")

#--------------------------------------------------------------------#


load_hmmouts <- function(inPath, suffix = 'tsv') {
  hmmFiles <- dir(inPath, pattern = paste('*.', suffix ,sep=''), full.names = T)
  hmmFiles <- hmmFiles[!grepl('tot_faa_stats.tsv', hmmFiles)]

  names(hmmFiles) <- basename(hmmFiles)

  lapply(hmmFiles, function(file){
    dfGenomeSeq <- data.frame(readFasta(file))
    print(paste('...loading', file))
    row.names(dfGenomeSeq) <- sub("^([^ ]+).*", "\\1", dfGenomeSeq$Header, perl=T)
    return(dfGenomeSeq)
  }) -> allSequences
  return(allSequences)
}


allhmm = load_hmmouts(inPath="~/DATA/MarbGenomics/dbCAN_TCDB", suffix = 'tsv')

inPath = "~/DATA/MarbGenomics/dbCAN_TCDB"
suffix = 'tsv'


read.delim('~/DATA/MarbGenomics/dbCAN_TCDB/Thalassolituus_oleivorans_strain_K188.tsv',header=FALSE)



#--------------------------------------------------------------------------------#
#
#   This allows users now to read hmmScan output files and filter them
#   (an Alternative approach to above DG pipeline extension)
#
#   Filtering is achieved by two methods
#
#     method = 'tophit' --> very fast selectes top (for KO, or other for which you dont expect more than one hit per gene)
#     method = 'cleanup' --> very slow, select filters non-overlapping best hits
#
#   Prefiltering can be achieved by settin e-value cutoff
#
#--------------------------------------------------------------------------------#
#   read_hmmscan_domtblout
#   read a hmmscan output file
#--------------------------------------------------------------------------------#

# Function that read input file (hmmscan, domtblout), tidies it up and compiles tibble

read_hmmscan_domtblout <- function(inPath){
  col_types <-
    readr::cols(
      domain_name         = readr::col_character(),
      domain_accession    = readr::col_character(),
      domain_len          = readr::col_integer(),
      query_name          = readr::col_character(),
      query_accession     = readr::col_character(),
      qlen                = readr::col_integer(),
      sequence_evalue     = readr::col_double(),
      sequence_score      = readr::col_double(),
      sequence_bias       = readr::col_double(),
      domain_N            = readr::col_integer(),
      domain_of           = readr::col_integer(),
      domain_cevalue      = readr::col_double(),
      domain_ievalue      = readr::col_double(),
      domain_score        = readr::col_double(),
      domain_bias         = readr::col_double(),
      hmm_from            = readr::col_integer(),
      hmm_to              = readr::col_integer(),
      ali_from            = readr::col_integer(),
      ali_to              = readr::col_integer(),
      env_from            = readr::col_integer(),
      env_to              = readr::col_integer(),
      acc                 = readr::col_double(),
      description         = readr::col_character()
    )

  N <- length(col_types$cols)

  output = readr::read_lines(inPath) %>%
    sub(
      pattern = sprintf("(%s) *(.*)", paste0(rep('\\S+', N-1), collapse=" +")),
      replacement = '\\1\t\\2',
      perl = TRUE
    ) %>%
    paste0(collapse="\n") %>%
    readr::read_tsv(col_names=c('X', 'description'), comment='#', na='-') %>%
    tidyr::separate(.data$X, head(names(col_types$cols), -1), sep=' +') %>%
    readr::type_convert(col_types=col_types)
  return(output)
}


#usage
#hmm_out = read_hmmscan_domtblout(inPath = '~/DATA/MarbGenomics/dbCAN_TCDB/Thalassolituus_oleivorans_strain_K188.out')
#hmm_out = read_hmmscan_domtblout(inPath = '~/DATA/MarbGenomics/dbCAN_KOfam/Marinobacter_halotolerans_NBRC_110910.out')
#hmm_out %>% group_by(query_name) %>% count(domain_name)

#---------------------------------------------------------------
#
#   hmmTophits, ignore multiple hits per gene, and take the best one
#     when you don't expect multiple hits per gene, please use hmmTophit(), if you do use hmmClean()
#
#--------------------------------------------------------------

hmmTophits <- function(hmm.out){
  #sort on evalue, and take the best hit
  hmm.keep <- hmm.out %>% group_by(query_name) %>% top_n(n=1, wt = -sequence_evalue) %>% slice(1)  # %>% ungroup()
  return(hmm.keep)
}

#usage
#hmm.tophits.df = hmmTophits(hmm.out = hmm_out)


#---------------------------------------------------------------
#
#   hmmClean to remove overlapping hits!
#     especially relevant if you expect multiple domains per gene (as often the case with pfam, CAZY etc)
#     when you don't expect multiple hits per gene, please use hmmTophit()
#
#--------------------------------------------------------------

#helper function
removeOverlap <-function(hmm.gene){
  tp.ht = hmm.gene %>% arrange(sequence_evalue) %>% slice(1)
  topfeauture <- tp.ht %>% select(domain_name) %>% pull
  starttophit <- tp.ht %>% select(ali_from) %>% pull
  endtophit <-tp.ht %>% select(ali_to) %>% pull

  hmm.remove_overlaps <-hmm.gene %>%
    mutate(tophit = ifelse(domain_name == topfeauture, TRUE, FALSE)) %>%
    mutate(overlap = ifelse(ali_from <= endtophit & ali_to >= starttophit,TRUE,FALSE)) %>%
    filter(overlap == TRUE & tophit == TRUE | overlap == FALSE & tophit == FALSE) #%>% select(-tophit,-overlap)
  return(hmm.remove_overlaps)
}

#usage
#removeOverlap(hmm.gene)
#--------------------------------------------------------------

hmmClean <- function(hmm.out){
  #Dereplicate Overlaps!
  qperlocus <- hmm.out %>% select(query_name) %>% table()
  singlehit <- names(qperlocus[qperlocus==1])
  multihit <- names(qperlocus[qperlocus>1])

  #keep the single domains per locus_tag
  hmm.keep <- hmm.out %>% filter(query_name %in% singlehit)

  #For those loci that have more than 1 hit, remove overlaps
  for(lc in multihit){
    #select given the selected locus
    hmm.gene <- hmm.out %>%
      filter(query_name == lc)

    #run utility function removeOverlaps()
    hmm.remove_overlaps <- removeOverlap(hmm.gene)

    #Keep the top hit (lowest e-value, and checked for overlaps)
    hmm.keep <- rbind(hmm.keep, hmm.remove_overlaps %>% slice(1) %>% select(-tophit,-overlap))

    #If we detected non-overlapping domains, keep on cleaning up (iteratively until no left)
    while(nrow(hmm.remove_overlaps)>1){
      hmm.remove_overlaps = hmm.remove_overlaps %>% slice(2:nrow(hmm.remove_overlaps))
      hmm.remove_overlaps = removeOverlap(hmm.remove_overlaps)
      hmm.keep = rbind(hmm.keep, hmm.remove_overlaps %>% slice(1) %>% select(-tophit,-overlap))
    }
  }
  return(hmm.keep)
}

#usage
hmm.clean.df = hmmClean(hmm.out = hmm_out)

#---------------------------------------------------------------------------------


hmm2df <-function(inPath='',method='tophit', evalue.cutoff = 1.e10, clean_genome_names=TRUE){
  hmm.df <- NULL
  hmmFiles <- dir(inPath, pattern = paste('*.', 'out' ,sep=''), full.names = T)

  for(x in hmmFiles){

    if(clean_genome_names==TRUE){
      genome = gsub('-','_',gsub('\\.','_', gsub('.out','',basename(x))))
    }else{
      genome = gsub('.out','',basename(x))
    }
    print(paste0('analysing: ',genome))

    #Load the file
    hmm.out <- read_hmmscan_domtblout(inPath = x)

    #Filter out low confidence hits based on evalue
    hmm.out <- hmm.out %>% filter(sequence_evalue <= evalue.cutoff)

    #Cleaning step
    if(method == 'tophit'){
      hmm.clean = hmmTophits(hmm.out = hmm.out)
    }
    if(method =='cleanup'){
      hmm.clean = hmmClean(hmm.out = hmm.out)
    }

    hmm.clean <- hmm.clean %>% mutate(genome=genome)
    hmm.df <- rbind(hmm.df, hmm.clean)
  }
  return(hmm.df)
}


#usage
#tcdb.tophit.tbl = hmm2df(inPath="~/DATA/MarbGenomics/dbCAN_TCDB", method='tophit',evalue.cutoff=1.e-10, clean_genome_names=TRUE)
#tcdb.cleanup.tbl = hmm2df(inPath="~/DATA/MarbGenomics/dbCAN_TCDB", method='cleanup',evalue.cutoff=1.e-10, clean_genome_names=TRUE)
#
# -- Sanity check ---
#dim(tcdb.tophit.pan )
#dim(tcdb.cleanup.pan)

#----------------------
#kofam with "tophit" (kofam for some reason has large files ~10-40MB, I wonder what this means)
#hence kofam is super slow, even with method = 'tophit'
kfm.tbl = hmm2df(inPath="~/DATA/MarbGenomics/dbCAN_KOfam", method="tophit",evalue.cutoff=1.e-10, clean_genome_names=TRUE)

#tcdb and cazy with "cleanup"
tcdb.tbl = hmm2df(inPath="~/DATA/MarbGenomics/dbCAN_TCDB", method="cleanup",evalue.cutoff=1.e-10, clean_genome_names=TRUE)
cazy.tbl = hmm2df(inPath="~/DATA/MarbGenomics/dbCAN", method="cleanup",evalue.cutoff=1.e-10, clean_genome_names=TRUE)

# Exytacy phylogenetic marrker sets Rinke and Campbell!?
Campbell.tbl = hmm2df(inPath="~/DATA/MarbGenomics/dbCAN_Campbell", method="tophit",evalue.cutoff=1.e-10, clean_genome_names=TRUE)
Rinke.tbl = hmm2df(inPath="~/DATA/MarbGenomics/dbCAN_Rinke", method="tophit",evalue.cutoff=1.e-10, clean_genome_names=TRUE)



# tbl2pan
#---------------------------------------------------------------------#

#' annotation tbl or gff tibble to pan!
#'
#' @param tbl
#' @param feature.col name of feature column
#'
#' @return
#' @export
#'
#' @examples
#' tcdb.tophit.pan = tbl2pan(tcdb.tophit.tbl)

tbl2pan <- function(tbl, feature.col='domain_name'){
  hmmpan <- tbl %>%
    dplyr::group_by(genome) %>%
    dplyr::count(!!as.name(feature.col)) %>%
    tidyr::spread(!!as.name(feature.col),n, fill=0) %>%
    data.frame()

  rownames(hmmpan) <- hmmpan[,1]
  hmmpan <- hmmpan[,c(2:ncol(hmmpan))]

  return(hmmpan)
}

#usage
#tcdb.tophit.pan = tbl2pan(tcdb.tophit.tbl)
#tcdb.cleanup.pan = tbl2pan(tcdb.cleanup.tbl)

#run
kfm.pan <- tbl2pan(tbl = kfm.tbl,feature.col = 'domain_name')
tcdb.pan <- tbl2pan(tbl = tcdb.tbl,feature.col = 'domain_name')
cazy.pan <- tbl2pan(tbl = cazy.tbl,feature.col = 'domain_name')


dim(kfm.pan)
dim(tcdb.pan)
dim(cazy.pan)

# Exytacy phylogenetic marrker sets Rinke and Campbell!?
#Campbell.pan <- tbl2pan(tbl = Campbell.tbl,feature.col = 'domain_name')
#Rinke.pan <- tbl2pan(tbl = Rinke.tbl,feature.col = 'domain_name')

#MAKE A PAN TABLE FROM THE ANNOTATION TABLE
#----------------------------------------#

#OG.pan
OG.pan.prep <- tbl2pan(tbl = annotation.tbl %>% select(locus_tag, genome, OG, product),
        feature.col='OG')

# contains X.NA. column that contains all those that were not in a OG, many of them were of too poor quality genomes for example
OG.pan = OG.pan.prep %>% select(!X.NA.)

#initially 117, (total genome set, but we did not analyse 11 of them using OG)
# we remove the ones with rowSums 0 (none)
OG.pan = OG.pan[ rowSums(OG.pan)!=0, ]


#MAKE A COG based PAN TABLE FROM THE ANNOTATION TABLE
#----------------------------------------#

# do the same with COGS!

COG.pan.prep <- tbl2pan(tbl = annotation.tbl %>% select(locus_tag, genome, COG, product),
                       feature.col='COG')
# contains X.NA. column that contains all those that were not in a COG, many of them were of too poor quality genomes for example
COG.pan = COG.pan.prep %>% select(!X.NA.)




#Save down files
write.table(OG.pan , file = "~/DATA/MarbGenomics/OG.pan.tsv")
write.table(COG.pan , file = "~/DATA/MarbGenomics/COG.pan.tsv")
write.table(kfm.pan , file = "~/DATA/MarbGenomics/kfm.pan.tsv")
write.table(tcdb.pan , file = "~/DATA/MarbGenomics/tcdb.pan.tsv")
write.table(cazy.pan , file = "~/DATA/MarbGenomics/cazy.pan.tsv")
write.table(pfam.pan , file = "~/DATA/MarbGenomics/pfam.pan.tsv")

write.table(annotation.tbl , file = "~/DATA/MarbGenomics/annotation.tbl.tsv")


write.table(annotation.tbl , file = "~/DATA/MarbGenomics/annotation.tbl.tsv")



#annotation.tbl <- read.delim2("~/DATA/MarbGenomics/annotation.tbl.tsv") %>% as_tibble()
#OG.pan <- read.table("~/DATA/MarbGenomics/OG.pan.tsv")
#COG.pan <- read.table("~/DATA/MarbGenomics/COG.pan.tsv")
#kfm.pan <- read.table("~/DATA/MarbGenomics/kfm.pan.tsv")
#tcdb.pan <- read.table("~/DATA/MarbGenomics/tcdb.pan.tsv")
#cazy.pan <- read.table("~/DATA/MarbGenomics/cazy.pan.tsv")



#----------------------------------------






# Let me explore this in another way

annotation.tbl %>%
  filter(is.na(OG)) %>%
  filter(genome == 'Marinobacter_sp_FDB33') %>%
  select(seqnames, locus_tag, product, type, OG) %>%
  filter(type == 'CDS') %>%
  group_by(seqnames) %>%
  count()

annotation.tbl %>%
  filter(is.na(OG)) %>%
  filter(genome == 'Marinobacter_sp_FDB33') %>%
  select(seqnames, locus_tag, product, type, OG) %>%
  filter(type == 'CDS') %>%
  filter(seqnames =='scaffold15.1')

#Section of genes, just dumped there!
# not homologous to other marinoabacter, yet in a nice cluster, interesting!

annotation.tbl %>%
  filter(is.na(OG)) %>%
  filter(genome == 'Marinobacter_algicola_DG893') %>%
  select(seqnames, locus_tag, product, type, OG) %>%
  filter(type == 'CDS') %>%
  group_by(seqnames) %>%
  filter(seqnames =='NZ_ABCP01000002')






#---------
# interesting to look at those unclustered genes! OFinder generated them as singletons, but are they, what are they?

#some random sanity test
#OG.pan.prep[setdiff(rownames(OG.pan.prep),rownames(OG.pan)),][1:10,1:10]

#Very interesting this one!
# novilty!
OG.pan.prep[rownames(OG.pan),] %>%
  dplyr::select(X.NA.) %>%
  tibble::rownames_to_column() %>%
  dplyr::rename(not_in_OG = 'X.NA.')
