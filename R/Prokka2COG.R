#--------------------------------------------------------------------------------#
# A lot of this is now obsolete, since we work with annotation table and tibbles
#
#   TO DO:
#     take mostabundantparalogs function to a better place!
#     normal transpose the pan! as well as the pan funcition
#
#

cog_func = read.delim('~/DATA/MarbGenomics/AnnotateMachine/COG_function.txt')
cog_desc = cog_func %>% select(COG, name) %>% unique()
rownames(cog_desc) = cog_desc$COG

#-----------------------------------------------------------------------------#
#
# 	UTILITY FUNCTIONS####
#
#-----------------------------------------------------------------------------#

#loadPorkkaTsv
#-----------------------------------------------------------------------------#
#' Loading Prokka derived .tsv files into a list object
#'
#' @param inPath
#' @param clean_genome_names
#'
#' @return
#' @export
#'
#' @examples
#' prokka_tsv_perGenome = loadPorkkaTsv(inPath='~/DATA/OrthoFinderMarinobacter/RecentAnalysis/Annotations2/prokka_output/', clean_genome_names=TRUE)

loadPorkkaTsv <- function(inPath='', clean_genome_names=TRUE){
	if(inPath==''){
		print("You'd need to specify a directory using inPath")
	}else{
		prokka_tsv_files <- list.files(
			path=inPath,
			pattern = ".tsv$",
			recursive = TRUE,
			include.dirs=TRUE,
			full.names=TRUE)

		prokka_tsv_perGenome = list()
		for(x in prokka_tsv_files){
			prokka_tsv = read.delim(x,header=TRUE)

			if(clean_genome_names==TRUE){
				genome = gsub('-','_',gsub('\\.','_', gsub('.tsv','',basename(x))))
			}else{
				genome = gsub('.tsv','',basename(x))
				}

			prokka_tsv_perGenome[[genome]]=cbind(prokka_tsv,'genome'=genome)
		}

	return(prokka_tsv_perGenome)
	}
}


#COGpan2COGCAT
#-----------------------------------------------------------------------------#
#' converts COG pan table to COG category pan table
#'
#' @param COGpan cog abundance/pan table (genomes x features)
#'
#' @return
#' @export
#'
#' @examples
#' COGCATpan = COGpan2COGCAT(COG.pan)

COGpan2COGCAT <-  function(COGpan){
  COGpan = data.frame(t(COGpan))
  COGCATlist = list()
  for(genome in colnames(COGpan)){
    COGCATlist[[genome]] <- COGpan %>%
      tibble::rownames_to_column(var='COG') %>%
      tidyr::as_tibble() %>%
      dplyr::select(COG, genome) %>%
      dplyr::rename('genome' = genome) %>%
      dplyr::filter(genome > 0 ) %>%
      dplyr::left_join(cog_func, by='COG') %>% count(func) %>% mutate('genome'=genome)
  }

  allgenome_countCOGCAT <- do.call('rbind', COGCATlist)
  allgenome_countCOGCAT

  COGCATpan <- tidyr::spread(allgenome_countCOGCAT, genome, n, fill = 0)
  COGCATpan <- COGCATpan %>% as.data.frame()
  rownames(COGCATpan)= COGCATpan[,1]
  COGCATpan = COGCATpan[,c(2:ncol(COGCATpan))]
  COGCATpan = COGCATpan[rowSums(COGCATpan)>0,]

  return(t(COGCATpan))
}

#-----------------------------------------------------------------------------#
# Noteworthy Plot ####

COGCATpan <- COGpan2COGCAT(COG.pan)

COGCATpan %>% t() %>%as.data.frame() %>%
  rownames_to_column(var='COGCAT') %>%
  pivot_longer(!COGCAT,names_to='genome') %>%
  right_join(metadata, by=c('genome'='BinId')) %>%
  filter(!(COGCAT %in% c('','A','B','W'))) %>%
  ggplot(aes(group,value))+
  geom_boxplot(aes(fill=group),alpha=0.5,show.legend=FALSE,outlier.shape=NULL)+
  geom_point(aes(fill=group),size=2,shape=21,show.legend=FALSE)+
  facet_wrap(~COGCAT,scales='free_y')+fdb_style(aspect.ratio = 0.5)



#-----------------------------------------------------------------------------#

# prokka2product <- function(prokkaTsvList = NULL, feature=NULL){
# 	if(is.null(prokkaTsvList)){
# 		print("You'd need to specify the object generated by loadProkkaTsv using 'prokkaTsvList'")
# 	}else{
# 		if(is.null(feature)){
# 			print("You'd need to specify a feature to grep for the function to work")
# 		}else{
#
# 			feature_perGenome = list()
# 			for(genome in names(prokkaTsvList)){
# 				selTsv = prokkaTsvList[[genome]]
# 				feature_perGenome[[genome]]= selTsv[grepl(feature,selTsv$product,ignore.case=TRUE),]
# 			}
# 			return(feature_perGenome)
# 		}
# 	}
# }

#usage
#transposases_perGenome = prokka2product(prokkaTsvList = prokka_tsv_perGenome, feature='transposase')

#-----------------------------------------------------------------------------#
#	Function to convert convert a COGlist object to a pangenome table

# feature2pan <- function(Featurelist = NULL){
# 	if(is.null(Featurelist)){
# 		print("You'd need to specify the object generated by loadProkkaTsv using 'prokkaTsvList'")
# 	}else{
# 		FeatureCountGenome = list()
# 		for(genome in names(Featurelist)){
# 			selFeaturetsv = Featurelist[[genome]]
# 			FeatureCountGenome[[genome]]=cbind(data.frame(table(selFeaturetsv$product)),'genome'=genome)
# 		}
# 		allgenome_countFeature <- do.call('rbind', FeatureCountGenome)
# 		Featurepan = tidyr::spread(allgenome_countFeature, genome, Freq, fill = 0)
# 		rownames(Featurepan)= Featurepan[,1]
# 		Featurepan = Featurepan[,c(2:ncol(Featurepan))]
# 		Featurepan = Featurepan[rowSums(Featurepan)>0,]
# 		return(Featurepan)
# 	}
# }

#usage
#transposase_pan = feature2pan(Featurelist = transposases_perGenome)

#-----------------------------------------------------------------------------#
#	Filtering only COG annotated proteins from prokka annotations

# prokka2COG <- function(prokkaTsvList = NULL){
# 	if(is.null(prokkaTsvList)){
# 		print("You'd need to specify the object generated by loadProkkaTsv using 'prokkaTsvList'")
# 	}else{
# 		COG_perGenome = list()
# 		for(genome in names(prokkaTsvList)){
# 			selTsv = prokkaTsvList[[genome]]
# 			COG_perGenome[[genome]]= selTsv[selTsv $COG !='',]
# 		}
# 		return(COG_perGenome)
# 	}
# }

#usage
#COG_perGenome = prokka2COG(prokkaTsvList = prokka_tsv_perGenome)

#-----------------------------------------------------------------------------#
#	Function to convert convert a COGlist object to a pangenome table

# COG2pan <- function(COGlist = NULL){
# 	if(is.null(COGlist)){
# 		print("You'd need to specify the object generated by loadProkkaTsv using 'prokkaTsvList'")
# 	}else{
# 		COGCountGenome = list()
# 		for(genome in names(COGlist)){
# 			selCOGtsv = COGlist[[genome]]
# 			COGCountGenome[[genome]]=cbind(data.frame(table(selCOGtsv$COG)),'genome'=genome)
# 		}
# 		allgenome_countCOG <- do.call('rbind', COGCountGenome)
# 		COGpan = tidyr::spread(allgenome_countCOG, genome, Freq, fill = 0)
# 		rownames(COGpan)= COGpan[,1]
# 		COGpan = COGpan[,c(2:ncol(COGpan))]
# 		COGpan = COGpan[rowSums(COGpan)>0,]
# 		return(COGpan)
# 	}
# }

#usage
#COGpan = COG2pan(COGlist = COG_perGenome)

#----------------------#

# FUNCTION TO MAP COGS TO COG categories, using COG pan tables and annotation file!




#-----------------------------------------------------------------------------#
#
# 	ProkCompR 	Prokka2COG.R
#
#-----------------------------------------------------------------------------#

# #laod all prokka .tsv output files and store in list of dataframes
# path_Prokka = '~/DATA/OrthoFinderMarinobacter/RecentAnalysis/Annotations2/prokka_output/'
# prokka_tsv_perGenome = loadPorkkaTsv(inPath=path_Prokka, clean_genome_names=TRUE)
#
# #Extract COG annotations from Prokka and store in list of dataframes
# COG_perGenome = prokka2COG(prokkaTsvList = prokka_tsv_perGenome)
#
# #Convert COG list of dataframes (prokka tsv style) into COG abundance matrix
# COGpan = COG2pan(COGlist = COG_perGenome)
#
# rm(COG_perGenome)
#
# #Select 10 most abundant COGs
# selected_var = mostAbundantParalogs(pan = COGpan, top_n = 10)
# selected_var
#
# #map to COGCATs
# COGCATpan = COGpan2COGCAT(COGpan)















#-------------------------------------------#
#-------------------------------------------#
#-------------------------------------------#
#-------------------------------------------#
  # OBSOLETE BUT FUN TO INTEGRATE!

#-----#


#Transposases

transposases_perGenome = prokka2product(prokkaTsvList = prokka_tsv_perGenome, feature='transposase')
transposase_pan = feature2pan(Featurelist = transposases_perGenome)
transposase_total_count = data.frame(colSums(transposase_pan))
colnames(transposase_total_count) = c('totalCount')

rm(transposases_perGenome)
rm(transposase_pan)
#rm(transposase_total_count)


#-------------------------------------------#
# Clean up
rm(prokka_tsv_perGenome)




df.chkm$transposases = transposase_total_count[rownames(df.chkm),]
df.chkm$hp = hp_count[rownames(df.chkm),]
df.chkm$hp_ratio = df.chkm$hp / df.chkm$predicted_genes
mean(df.chkm$hp_ratio)


df.chkm$selgene = gene_total_count[rownames(df.chkm),]


df.chkm %>%
  select(BinId, Genome_size , GC, Coding_density, predicted_genes) %>%
  pivot_longer(GC:predicted_genes) %>%
  ggplot(aes(Genome_size/1000000, value)) +
    geom_point(shape = 21, size = 2,fill='grey',show.legend=FALSE) +
    theme_classic() +
    geom_smooth(method='lm',size=0.5,color='red')+
    ggpubr::stat_cor(method = "pearson") +
    theme_classic() +
    theme(
      aspect.ratio = 1,
      plot.title = element_text(hjust = 0.5),
      axis.title = element_text(size = 11, colour = '#000000'),
      axis.text = element_text(size = 10, colour = '#000000'),
      legend.justification = c(1, 1),
      legend.key.width = unit(0.25, 'cm'),
      legend.key.height = unit(0.55, 'cm'),
      legend.text = element_text(size = 10),
      legend.title = element_text(size = 11))+
    facet_wrap(~name,scales='free',strip.position = "left",
        labeller = as_labeller(c(GC = "GC-content (%)", Coding_density = "Coding density",predicted_genes='predicted ORFs')))+
    theme(strip.background = element_blank(),
        strip.placement = "outside",
        strip.text = element_text(size = 11))+ylab('')+xlab('Genome size (Mbp)')


#--- we could do some hyeprgeometic tests here, to show that there are differences
#--- testing whether a single CPG family is associated with one of the groups
#--- alos, we could test using RF which genes associate very well with total nr of ORFs per genome... (or other regression type based RFs)
#   with the idea to say what does affect this the best, could also be categorical predicors or not
# things to think about, read lit and draft paper...
min(df.chkm$Genome_size)/max(df.chkm$Genome_size)
max(df.chkm$Genome_size) - min(df.chkm$Genome_size)
mean(df.chkm$Genome_size)
sd(df.chkm$Genome_size)
#does our pattern of genome reduction link up with habitat like endosymbionts, or higher dependency on other organsms
df.chkm[df.chkm$Genome_size < 3500000, ]

ggplot(df.chkm,aes(predicted_genes, selgene)) +
  xlab('predicted ORFs') +
  ylab('hypothetical proteins') +
  geom_point(shape = 21, size = 2,fill='grey') +
  theme_classic() +
  geom_smooth(method='lm',size=0.5,color='red')+
  ggpubr::stat_cor(method = "pearson") +
  theme(
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    axis.title = element_text(size = 11, colour = '#000000'),
    axis.text = element_text(size = 10, colour = '#000000'),
    #legend.position = c(1, 1),
    legend.justification = c(1, 1),
    legend.key.width = unit(0.25, 'cm'),
    legend.key.height = unit(0.55, 'cm'),
    legend.text = element_text(size = 10),
    #legend.text.align = 1,
    legend.title = element_text(size = 11))


ggplot(df.chkm,aes(predicted_genes, hp)) +
  xlab('predicted ORFs') +
  ylab('hypothetical proteins') +
  geom_point(shape = 21, size = 2,fill='grey') +
  theme_classic() +
  geom_smooth(method='lm',size=0.5,color='red')+
  ggpubr::stat_cor(method = "pearson") +
  theme(
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    axis.title = element_text(size = 11, colour = '#000000'),
    axis.text = element_text(size = 10, colour = '#000000'),
    #legend.position = c(1, 1),
    legend.justification = c(1, 1),
    legend.key.width = unit(0.25, 'cm'),
    legend.key.height = unit(0.55, 'cm'),
    legend.text = element_text(size = 10),
    #legend.text.align = 1,
    legend.title = element_text(size = 11))


ggplot(df.chkm,aes(Genome_size/1000000, hp)) +
  xlab('Genome size (Mbp)') +
  ylab('hypothetical proteins') +
  geom_point(shape = 21, size = 2,fill='grey') +
  theme_classic() +
  geom_smooth(method='lm',size=0.5,color='red')+
  ggpubr::stat_cor(method = "pearson") +
  theme(
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    axis.title = element_text(size = 11, colour = '#000000'),
    axis.text = element_text(size = 10, colour = '#000000'),
    #legend.position = c(1, 1),
    legend.justification = c(1, 1),
    legend.key.width = unit(0.25, 'cm'),
    legend.key.height = unit(0.55, 'cm'),
    legend.text = element_text(size = 10),
    #legend.text.align = 1,
    legend.title = element_text(size = 11))



ggplot(df.chkm,aes(Genome_size/1000000, transposases)) +
  	xlab('Genome size (Mbp)') +
	ylab('Detected transposases') +
	geom_point(shape = 21, size = 2,fill='grey') +
	theme_classic() +
	geom_smooth(method='lm',size=0.5,color='red')+
	ggpubr::stat_cor(method = "pearson") +
	theme(
		aspect.ratio = 1,
		plot.title = element_text(hjust = 0.5),
		axis.title = element_text(size = 11, colour = '#000000'),
        axis.text = element_text(size = 10, colour = '#000000'),
        #legend.position = c(1, 1),
        legend.justification = c(1, 1),
        legend.key.width = unit(0.25, 'cm'),
        legend.key.height = unit(0.55, 'cm'),
        legend.text = element_text(size = 10),
        #legend.text.align = 1,
        legend.title = element_text(size = 11))

ggplot(df.chkm,aes(Coding_density, transposases)) +
	xlab('Coding density (Mbp)') +
	ylab('Detected transposases') +
	geom_point(shape = 21, size = 2,fill='grey') +
	theme_classic() +
	geom_smooth(method='lm',size=0.5,color='red')+
	ggpubr::stat_cor(method = "pearson") +
	theme(
		aspect.ratio = 1,
		plot.title = element_text(hjust = 0.5),
		axis.title = element_text(size = 11, colour = '#000000'),
        axis.text = element_text(size = 10, colour = '#000000'),
        #legend.position = c(1, 1),
        legend.justification = c(1, 1),
        legend.key.width = unit(0.25, 'cm'),
        legend.key.height = unit(0.55, 'cm'),
        legend.text = element_text(size = 10),
        #legend.text.align = 1,
        legend.title = element_text(size = 11))


# ---- PARALOG EXPANSION?!
#---------------------------#


panRankedParalogs = data.frame(sort(rowSums(COGpan),decreasing=TRUE))
colnames(panRankedParalogs) = c('count')

selected_var = head(rownames(panRankedParalogs),50)
selected_var = head(rownames(panRankedParalogs),20)
#selected_var = rownames(COGpan)
selected_var = head(rownames(panRankedParalogs),500)


scaleRYG <- colorRampPalette(c("white","cornflowerblue",'yellow','red'), space = "rgb")(30)
scaleRYG <-  c(colorRampPalette(c("white", "cornflowerblue"))(10), colorRampPalette(c("yellow", "red"))(10))



p <- ggtree(tree, branch.length="none", size=0.5)

#p2 = open_tree(p, 20)
p2 = p



gheatmap(p2, t(COGpan[selected_var,])[,hclust(dist((COGpan[selected_var,])))$order],offset=-1, width=1.5, colnames_angle = 90,hjust=1, font.size=2)+
  scale_fill_gradientn(colours = scaleRYG,name='pI bias')+theme(
		aspect.ratio = 1,
		plot.title = element_text(hjust = 0.5),
		axis.title = element_text(size = 11, colour = '#000000'),
        axis.text = element_text(size = 10, colour = '#000000'),
        #legend.position = c(1, 1),
        legend.justification = c(1, 1),
        legend.key.width = unit(0.25, 'cm'),
        legend.key.height = unit(0.55, 'cm'),
        legend.text = element_text(size = 10),
        #legend.text.align = 1,
        legend.title = element_text(size = 11))

#---- correlation matrix of top 50 most abundant paralogs

cor_res = cor(t(COGpan[selected_var,]))

library(corrplot)
corrplot(cor_res, type = "upper", order = "hclust", tl.col = "black", tl.srt = 45, col= colorRampPalette(brewer.pal(n=11, name="BrBG"))(20),tl.cex=0.6)
corrplot(cor_res, order = "hclust", tl.col = "black", col= colorRampPalette(brewer.pal(n=11, name="BrBG"))(20),tl.cex=0.6)


#-----------#

df = t(COGpan[selected_var,])
df = df %>%
	map_lgl(~sd(.) !=0) %>%
	extract(df, .)

df = df[vapply(df, function(x) length(unique(na.omit(x)))>1, logical(1L))]

df <- df[, sapply(df, function(x) { sd(x) != 0} )]



#----#

g <- graph_from_adjacency_matrix(as.matrix(cor_res), mode = "upper", weighted = T, diag = F)
g2 <- delete.edges(g, which(E(g)$weight <0.95))
plot(g2)
wc <- cluster_walktrap(g2)
modularity(wc)
membership(wc)
plot(wc, g2)

g5 <- delete.edges(g, which(E(g)$weight <0.95))
E(g5)$weight = 0.5
LO = layout_with_fr(g5)
#V(g5)$color <- colorRampPalette(brewer.pal(9, "Set1"))(38)[as.factor(gsub('_.*$','', names(V(g5))))]
#plot(g5, layout=LO, vertex.size=5, vertex.label="")
plot(g5, vertex.size=5, vertex.label="")

#-----------#
mbship = membership(wc)

rankedMembership = sort(table(membership(wc)),decreasing=TRUE)

selCOGs = names(mbship[mbship == names(rankedMembership[1])])
selCOGs = names(mbship[mbship == names(rankedMembership[2])])
selCOGs = names(mbship[mbship == names(rankedMembership[3])])
selCOGs = names(mbship[mbship == names(rankedMembership[4])])
selCOGs = names(mbship[mbship == names(rankedMembership[5])])

selCOGs = c(names(mbship[mbship == names(rankedMembership[1])]),
			names(mbship[mbship == names(rankedMembership[2])]),
			names(mbship[mbship == names(rankedMembership[3])]),
			names(mbship[mbship == names(rankedMembership[4])]),
			names(mbship[mbship == names(rankedMembership[5])])
			)

selected_var = selCOGs

selected_var = names(mbship[mbship == '1'])
selected_var = names(mbship[mbship == '2'])
selected_var = names(mbship[mbship == '3'])

cog_desc[selected_var,]

cog_desc[selCOGs,]

selected_var = as.character(cog_desc[grepl('nitr', cog_desc$name),]$COG)
selected_var = intersect(rownames(COGpan), selected_var)
